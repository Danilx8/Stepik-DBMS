Напишите запрос, считающий в дереве, хранимом в виде списков смежностей, для каждой вершины размер её поддерева.

У вас есть таблица, в которой записано случайное дерево из 50 вершин в виде списков смежностей.

    CREATE TABLE Keyword(
      id INT PRIMARY KEY, 
      value TEXT, -- некое значение, не имеющее смысла для целей этой задачи
      parent_id INT REFERENCES Keyword DEFAULT NULL);
    
    -- Пример таблицы
    Keyword                   
    id  parent_id value
    -------------------
    0   NULL      'qwerty'
    1   0         'asdfg'
    2   0         'zxcvb'
    3   1         'yuiop'
    4   1         'ghjkl'
    
    

  

Вам нужно для каждой вершины вычислить размер возглавляемого ей поддерева, включая саму вершину. Для вышеприведённого примера результат получится таким:

    id  subtree_size
    -------------
    0   5
    1   3
    2   1
    3   1
    4   1

  

**Требования к решению и материалы для тестирования**  

Нужно написать запрос, в результате которого будут следующие столбцы, в порядке очередности:

1.  **id INT**: идентификатор вершины, такой же как и в таблице Keyword
2.  **subtree\_size BIGINT**: размер поддерева, включая саму вершину. Тип BIGINT, скорее всего, получится автоматически, но вы можете явно привести результат оператором ::BIGINT. При несоответствии типов ожидаемым  вам предложат проверить, нет ли в запросе синтаксических ошибок и возвращает ли он ровно то, что требуется. Это же сообщение может появиться и по другим поводам, например если у вас действительно есть синтаксические ошибки.

Пример валидного, но неправильного решения:  

    
    SELECT 0 as id, 50::BIGINT AS subtree_size;

Вы можете [скачать из материалов курса](https://stepik.org/media/attachments/lesson/50193/task3-public.sql) скрипт, создающий таблицу и заполняющий её случайными данными.

  
**Подсказки**

Эта задача не очень сложна теоретически, но практически хорошее решение не очевидно и его написание сталкивается с техническими ограничениями рекурсивных запросов, например невозможности использовать рабочую таблицу в подзапросах или более одного раза в рекурсивной части.

Хорошее компактное решение, однако, занимает 12 хорошо форматированных строчек. Подумайте, нельзя ли использовать имеющиеся в постгресе [операции с массивами](https://postgrespro.ru/docs/postgrespro/9.6/functions-array), такие как конкатенация и разворачивание массива в строки запроса.

  

\[1\] [Скрипт, генерирующий схему и данные](https://stepik.org/media/attachments/lesson/50193/task3-public.sql "Link: /media/attachments/lesson/20190/m6hw2_schema.sql")