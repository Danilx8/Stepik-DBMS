Вам нужно расставить ключи и внешние ключи в небольшой базе данных. Пример, разумеется, несколько синтетичен и вы легко сможете привести опровержения тех или иных условий, перечисленных  ниже. Не тратьте, пожалуйста, время на доказательство неправильности условий. Примите за данность, что в нашем мире условия вот  такие какие есть.

**Схема базы данных**

БД состоит из трёх таблиц:

    -- Название конференции, без года (например 'SIGMOD') и описание
    
    CREATE TABLE Conference(
        name TEXT,
        description TEXT
    );
    
    -- Площадка для проведения конференции, представляющая из себя большое здание. 
    -- Разные площадки расположены в разных зданиях.
    -- У площадки есть имя (например, 'Кремлевский Дворец Съездов'),
    -- город, в котором она расположена, страна, и географические координаты с точностью до 5 знаков 
    -- после запятой, что соответствует единицам метров на местности в средних широтах
    CREATE TABLE Venue(
        id INTEGER PRIMARY KEY,
        name TEXT,
        city TEXT,
        country TEXT,
        lat NUMERIC(7,5),
        lon NUMERIC(8,5)
    );
    
    -- Статья, принятая на конференцию и опубликованная в трудах конференции
    -- Строка в таблице утверждает, что статья с названием title была опубликована в трудах 
    -- конференции conference, проходившей на площадке venue_id в year году, 
    -- трудам был присвоен isbn код, и статью следует искать на странице page
    
    CREATE TABLE PaperSubmission(
      id INTEGER PRIMARY KEY,
      conference TEXT,
      year INTEGER,
      title TEXT,
      isbn TEXT,
      page INTEGER,
      venue_id INTEGER
    );

  
  
Если называть проведение конференции в конкретном году событием, то мы знаем, что одноименных статей на одном событии не бывает, что событие проходит только на одной площадке (последнее условие гарантировать ключом не требуется).

  

Конференция проходит раз в год. Одноимённых конференций не бывает.  

  

Каждая площадка представляет из себя отдельное здание довольно больших размеров и площади. В нашем мире двух площадок в одном здании не бывает. Все статьи длинные, не менее чем несколько страниц длиной.

  

Все остальные свойства вполне ожидаемые и естественные:

площадки могут принимать разные события, конференции могут менять площадки год от года, в городе может быть много площадок, в стране много городов.

  

ISBN -- это [международный стандартный книжный номер](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%B4%D1%83%D0%BD%D0%B0%D1%80%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9_%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BD%D0%B8%D0%B6%D0%BD%D1%8B%D0%B9_%D0%BD%D0%BE%D0%BC%D0%B5%D1%80), уникальный для каждой изданной книги или сборника.

**Задание**

Вам нужно расставить ограничения ключей и внешних ключей в этих таблицах. Для этого нужно модифицировать приведённый выше SQL код таблиц синтаксически и логически правильным образом, то есть дописать соответствующие ключевые слова в нужных местах. В качестве решения нужно послать три оператора CREATE TABLE. Вышенаписанный код будет валидным решением, хоть и неправильным.

Обратите внимание, что в диалекте PostgreSQL слова FOREIGN KEY в ограничении столбца не нужны, а в ограничении таблицы нужны:  
  

    CREATE TABLE Foo(bar_id INT REFERENCES Bar(id))
    -- но 
    CREATE TABLE Foo(bar_id INT, FOREIGN KEY(bar_id) REFERENCES Bar(id)).
    

  

Помните о том, что ключи бывают составными.  
  

**Как проверяется**

Робот выполняет переданные ему операторы CREATE TABLE, после чего проводит 15 проверок, перед каждой проверкой удаляя все строки из таблиц. Проверки выполняются до первой неудачи. В каждой проверке робот проверяет наличие или отсутствие того или иного ограничения, выполняя операторы INSERT. Если у него получилось сделать то, что по его мнению не должно было получиться или наоборот, не получилось сделать то, что по его мнению вполне законно, он вам даст более или менее туманный намек. Если вы не используете ничего экзотического, намеки будут соответствовать действительности. Но нетрудно создать такую схему, в которой намёк не будет иметь ничего общего с рельностью. Поэтому относитесь к намекам робота критически и полагайтесь на свой здравый смысл.  
  
Не заключайте идентификаторы (например имена таблиц) в двойные кавычки -- это нарушит case-insensitiveness, на которую робот полагается.  

Проверка выполняется внешним сервисом. Обычно в течение 15 секунд вы должны получить ответ. При нагрузке время ответа может возрасти, но все равно за 5 минут решение должно быть проверено. Если вы не получаете ответ в течение 5 минут, сообщите об этом в комментарии.

Настоятельно рекомендуем не откладывать отсылку решения на последний час перед дедлайном. Рекомендуем проводить основные эксперименты на своем компьютере, и отсылать уже готовый результат, который хотя бы является синтаксически правильным. В случае синтаксической ошибки робот скажет вам только о факте её наличия, без подробностей.